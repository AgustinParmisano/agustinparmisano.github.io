<html>
	<head>
		<title>Rainbow Circle Following Mouse</title>
		<style>
			body { margin: 0; overflow: hidden; }
			canvas { width: 100%; height: 100%; display: block; }
		</style>
	</head>
	<body>
		<script src="assets/js/three.min.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			// Crear una esfera (círculo en 3D) principal
			var geometry = new THREE.SphereGeometry( 0.5, 32, 32 );
			var material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
			var sphere = new THREE.Mesh( geometry, material );
			scene.add( sphere );

			camera.position.z = 5;

			// Variables para el seguimiento del mouse
			var mouseX = 0;
			var mouseY = 0;
			var targetX = 0;
			var targetY = 0;

			// Variable para el color del arcoíris
			var hue = 0;

			// Array para guardar las esferas de la estela
			var trail = [];
			var lastTrailTime = 0;
			var trailInterval = 50; // Crear nueva esfera cada 50ms

			// Función para convertir coordenadas del mouse a coordenadas 3D
			function onMouseMove( event ) {
				// Convertir coordenadas del mouse a coordenadas normalizadas (-1 a 1)
				mouseX = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouseY = -( event.clientY / window.innerHeight ) * 2 + 1;

				// Convertir a coordenadas 3D usando el viewport
				var vector = new THREE.Vector3( mouseX, mouseY, 0.5 );
				vector.unproject( camera );

				var dir = vector.sub( camera.position ).normalize();
				var distance = -camera.position.z / dir.z;
				targetX = camera.position.x + dir.x * distance;
				targetY = camera.position.y + dir.y * distance;
			}

			window.addEventListener( 'mousemove', onMouseMove, false );

			// Función para convertir HSL a hexadecimal
			function hslToHex(h, s, l) {
				h /= 360;
				s /= 100;
				l /= 100;
				var r, g, b;
				if (s === 0) {
					r = g = b = l;
				} else {
					var hue2rgb = function(p, q, t) {
						if (t < 0) t += 1;
						if (t > 1) t -= 1;
						if (t < 1/6) return p + (q - p) * 6 * t;
						if (t < 1/2) return q;
						if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
						return p;
					};
					var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
					var p = 2 * l - q;
					r = hue2rgb(p, q, h + 1/3);
					g = hue2rgb(p, q, h);
					b = hue2rgb(p, q, h - 1/3);
				}
				return Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
			}

			// Función para crear una nueva esfera en la estela
			function createTrailSphere(x, y, color) {
				var trailGeometry = new THREE.SphereGeometry( 0.4, 32, 32 );
				var trailMaterial = new THREE.MeshBasicMaterial( { 
					color: color,
					transparent: true,
					opacity: 0.8
				} );
				var trailSphere = new THREE.Mesh( trailGeometry, trailMaterial );
				trailSphere.position.x = x;
				trailSphere.position.y = y;
				trailSphere.position.z = 0;
				scene.add( trailSphere );
				
				return {
					mesh: trailSphere,
					createdAt: Date.now(),
					color: color
				};
			}

			var render = function () {
				requestAnimationFrame( render );

				var currentTime = Date.now();

				// Actualizar posición del círculo suavemente hacia el mouse
				sphere.position.x += (targetX - sphere.position.x) * 0.1;
				sphere.position.y += (targetY - sphere.position.y) * 0.1;

				// Actualizar color del arcoíris
				hue = (hue + 2) % 360; // Incrementar el tono (0-360)
				var color = hslToHex(hue, 100, 50); // Saturación 100%, Luminosidad 50%
				material.color.setHex(color);

				// Crear nueva esfera en la estela cada cierto intervalo
				if (currentTime - lastTrailTime >= trailInterval) {
					var trailSphere = createTrailSphere(sphere.position.x, sphere.position.y, color);
					trail.push(trailSphere);
					lastTrailTime = currentTime;
				}

				// Actualizar opacidad y eliminar esferas viejas de la estela
				var trailLifetime = 3000; // 3 segundos en milisegundos
				for (var i = trail.length - 1; i >= 0; i--) {
					var trailItem = trail[i];
					var age = currentTime - trailItem.createdAt;
					
					if (age >= trailLifetime) {
						// Eliminar esfera después de 3 segundos
						scene.remove(trailItem.mesh);
						trailItem.mesh.geometry.dispose();
						trailItem.mesh.material.dispose();
						trail.splice(i, 1);
					} else {
						// Actualizar opacidad basada en la edad (fade out)
						var opacity = 0.8 * (1 - age / trailLifetime);
						trailItem.mesh.material.opacity = opacity;
					}
				}

				renderer.render(scene, camera);
			};

			render();
		</script>
	</body>
</html>
